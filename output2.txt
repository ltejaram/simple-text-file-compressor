The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack.The above function is recursive, so uses function call stack to store intermediate values of l and h. The function call stack stores other bookkeeping information together with parameters. Also, function calls involve overheads like storing activation record of the caller function and then resuming execution. Unlike Iterative QuickSort, the iterative MergeSort doesn’t require explicit auxiliary stack 